using BankAccountNS;

namespace Projects {
    
    internal class Program {

        public static void Main() {
            BankAccount ba = new BankAccount("Mr. Bryan Walton", 11.99);

            ba.Credit(5.77);
            ba.Debit(11.22);
            Console.WriteLine("Current balance is ${0}", ba.Balance);
        }
    }
}

/* Фреймворк MSTest. */
/* В основе тестирования лежит идея о том, что мы, как разработчики, знаем наверняка то, что нам
 * требуется. Конкретно и по существу. Поэтому нам нужен инструмент этой самой проверки желаемого
 * результата и суровой действительности. Для этого у нас есть статический класс Assert с массой
 * статических методов для проверки.
 * Как правило, в основном это методы с двумя аргументами — expected и actual, т.е. то, что мы 
 * ожидаем и то, что мы получили. В случае если наше поведение не соответствует нашему ожиданию
 * — тест «валится», становится красным и мы при помощи Test Explorer можем понять что и где 
 * пошло не так. Также, в перегрузках методов можно найти строковую переменную message и задать
 * текст ошибки — в каждом отдельном случае.
 * Также следует отметить, что существует также и методы, внутрь которых не нужно передавать эти
 * самые expected и actual. Для ситуаций, когда нам нужно проверить, что мы ожидаем получить
 * какой-либо Exception, к примеру, существует метод ThrowsException.
 */

/* Методы:

 * AreEqual — Метод проверяет эквивалентность наших аргументов и в случае их полного соответствия 
 — тест проходит, в обратном случае — падает. В перегрузках кроме object есть фактически все 
 - примитивы, иногда со своими какими-то точечными подстройками (к примеру, для сравнения строк 
 - можно игнорировать чувствительность к регистру или задавать дельту допустимой погрешности для
 - сравнения float).

 * AreNotEqual — как следует из названия, функция, обратная по смыслу AreEqual — тест проходит
 - в случае, если аргументы НЕ являются эквивалентными и падает, если они равны, соответственно.

 * AreSame — проверка эквивалентности по указателю. В случае если оба объекта имеет одинаковую
 - ссылку и ведут на один и тот же объект — тест проходит, в противном случае — падает.

 * AreNotSame — обратная проверка AreSame на НЕ одинаковую ссылку.
 * IsTrue, IsFalse — проверка предикатов на истинность или ложь.
 * IsNull, IsNotNull — проверка на то, что объект является пустым (null) или же наоборот, что объект не является пустым.
 * IsInstanceOfType, IsNotInstanceOfType — проверка на соответствие типов объекта.
 * ThrowsException — проверка на то, что ожидаемым поведением должен быть Exception.
 * Fail — метод, который «валит» тест с определённым сообщением. Таким образом вы можете 
 - абстрагироваться от предустановленных имеющихся подходов и реализовать свой собственный.
 - Любая кастомная проверка, в которой нет ошибки или Exception будет считать «зелёным» пройденным тестом.

 [---Атрибуты---]
 - Для того, чтобы фреймворк знал какие из наших методов и классов связаны с тестами и как с ними
 - работать вообще — используются специальные атрибуты, со своим жизненным циклом: сначала мы 
 - инициализируем настройки сборки, далее идём в настройки класса, после чего попадаем в тест
 - метод, из него чистим класс и в самом конце чистим сборку: 
 - AssemblyInitialize, TestClass, TestInitialize, TestMethod, TestCleanup, AssemblyCleanup.

 - Как видно из названия, часть из атрибутов ориентированы на работу с глобальным состоянием.
 - В частности, AssemblyInitialize начинает работу первым и единожды на весь запуск тестов. 
 - Здесь мы можем получить какие-то глобальные настройки, проинициализировать необходимые нам
 - данные (к примеру, базу данных). Соответственно, AssemblyCleanup отработает в самом конце
 - и также только один раз — специально для того, чтобы вы «почистили» то, что необходимо 
 - почистить — закрыли соединения, провели какие-то постработы. Для обоих данных атрибутов 
 - требуется статические методы и данные атрибуты можно указать в проекте лишь один раз, 
 - иначе тесты не заведутся.

 * TestInitialize — работает на уровне класса. И при создания экземпляра тестового класса 
 - управление перейдет в первую очередь в метод, который отмечен данным атрибутом. 
 - Здесь мы можем провести какие-то инициирующие операции близкие к контексту класса, возможно, 
 - логер или какие-то другие необходимые для класса вещи.
 
 * TestCleanup, соответственно, отработает после всех тестовых методов класса и здесь вы сможете
 - подвести некоторой итог вашей работы и, опять-таки, почиститься.

 * TestClass — атрибут, который мы отмечаем класс с тестовыми методами.

 * TestMethod, соответственно, как видно из названия — для методов.

 * Также существуют специальные мета атрибуты для организации и структурирования наших тестов.
 - Речь идёт о TestCategory, при помощи которого мы можем указать к какой группе относится данный
 - метод. К слову, группировка в Test Explorer доступна по файлам и классам, таким образом при
 - грамотном распределении тестов на файловой системе — надобность задавать категории в ручном 
 - режиме может отпасть.
 */